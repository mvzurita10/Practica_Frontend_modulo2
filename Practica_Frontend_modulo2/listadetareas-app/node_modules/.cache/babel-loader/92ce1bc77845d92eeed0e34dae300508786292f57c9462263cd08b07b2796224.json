{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\n\n// Función para cargar el estado inicial desde localStorage\nconst loadState = () => {\n  try {\n    const serializedState = localStorage.getItem('todos');\n    if (serializedState === null) {\n      return []; // Si no hay nada guardado, retorna un array vacío\n    }\n    return JSON.parse(serializedState);\n  } catch (err) {\n    console.error(\"Could not load state from localStorage\", err);\n    return []; // En caso de error, retorna un array vacío\n  }\n};\n\n// Función para guardar el estado en localStorage\nconst saveState = state => {\n  try {\n    const serializedState = JSON.stringify(state);\n    localStorage.setItem('todos', serializedState);\n  } catch (err) {\n    console.error(\"Could not save state to localStorage\", err);\n    // Manejar errores de escritura si es necesario\n  }\n};\nconst initialState = loadState(); // Carga el estado inicial\n\nexport const todoSlice = createSlice({\n  name: 'todos',\n  initialState,\n  reducers: {\n    // Acción para añadir una nueva tarea\n    addTodo: (state, action) => {\n      const newTodo = {\n        id: Date.now(),\n        // ID simple basado en timestamp\n        text: action.payload,\n        // El texto viene en el payload de la acción\n        completed: false // Por defecto, las tareas no están completadas\n      };\n      state.push(newTodo); // Añade la nueva tarea al array (Redux Toolkit permite \"mutar\" el estado aquí)\n      saveState(state); // Guarda el nuevo estado en localStorage\n    },\n    // Acción para eliminar una tarea\n    deleteTodo: (state, action) => {\n      const newState = state.filter(todo => todo.id !== action.payload); // Filtra el ID a eliminar\n      saveState(newState); // Guarda el nuevo estado en localStorage\n      return newState; // Retorna el nuevo array filtrado\n    },\n    // (Opcional) Acción para marcar una tarea como completada/incompleta\n    toggleTodo: (state, action) => {\n      const todo = state.find(todo => todo.id === action.payload);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n      saveState(state); // Guarda el estado actualizado\n    }\n  }\n});\n\n// Exporta las acciones generadas automáticamente por createSlice\nexport const {\n  addTodo,\n  deleteTodo,\n  toggleTodo\n} = todoSlice.actions;\n\n// Exporta el reducer generado\nexport default todoSlice.reducer;","map":{"version":3,"names":["createSlice","loadState","serializedState","localStorage","getItem","JSON","parse","err","console","error","saveState","state","stringify","setItem","initialState","todoSlice","name","reducers","addTodo","action","newTodo","id","Date","now","text","payload","completed","push","deleteTodo","newState","filter","todo","toggleTodo","find","actions","reducer"],"sources":["D:/Josue/Miky/code/Practica_Frontend_modulo2/Practica_Frontend_modulo2/listadetareas-app/src/store/TodoSlice.js"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\r\n\r\n// Función para cargar el estado inicial desde localStorage\r\nconst loadState = () => {\r\n  try {\r\n    const serializedState = localStorage.getItem('todos');\r\n    if (serializedState === null) {\r\n      return []; // Si no hay nada guardado, retorna un array vacío\r\n    }\r\n    return JSON.parse(serializedState);\r\n  } catch (err) {\r\n    console.error(\"Could not load state from localStorage\", err);\r\n    return []; // En caso de error, retorna un array vacío\r\n  }\r\n};\r\n\r\n// Función para guardar el estado en localStorage\r\nconst saveState = (state) => {\r\n  try {\r\n    const serializedState = JSON.stringify(state);\r\n    localStorage.setItem('todos', serializedState);\r\n  } catch (err) {\r\n    console.error(\"Could not save state to localStorage\", err);\r\n    // Manejar errores de escritura si es necesario\r\n  }\r\n};\r\n\r\nconst initialState = loadState(); // Carga el estado inicial\r\n\r\nexport const todoSlice = createSlice({\r\n  name: 'todos',\r\n  initialState,\r\n  reducers: {\r\n    // Acción para añadir una nueva tarea\r\n    addTodo: (state, action) => {\r\n      const newTodo = {\r\n        id: Date.now(), // ID simple basado en timestamp\r\n        text: action.payload, // El texto viene en el payload de la acción\r\n        completed: false, // Por defecto, las tareas no están completadas\r\n      };\r\n      state.push(newTodo); // Añade la nueva tarea al array (Redux Toolkit permite \"mutar\" el estado aquí)\r\n      saveState(state); // Guarda el nuevo estado en localStorage\r\n    },\r\n    // Acción para eliminar una tarea\r\n    deleteTodo: (state, action) => {\r\n      const newState = state.filter(todo => todo.id !== action.payload); // Filtra el ID a eliminar\r\n      saveState(newState); // Guarda el nuevo estado en localStorage\r\n      return newState; // Retorna el nuevo array filtrado\r\n    },\r\n    // (Opcional) Acción para marcar una tarea como completada/incompleta\r\n    toggleTodo: (state, action) => {\r\n       const todo = state.find(todo => todo.id === action.payload);\r\n       if (todo) {\r\n         todo.completed = !todo.completed;\r\n       }\r\n       saveState(state); // Guarda el estado actualizado\r\n    }\r\n  },\r\n});\r\n\r\n// Exporta las acciones generadas automáticamente por createSlice\r\nexport const { addTodo, deleteTodo, toggleTodo } = todoSlice.actions;\r\n\r\n// Exporta el reducer generado\r\nexport default todoSlice.reducer;"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAkB;;AAE9C;AACA,MAAMC,SAAS,GAAGA,CAAA,KAAM;EACtB,IAAI;IACF,MAAMC,eAAe,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;IACrD,IAAIF,eAAe,KAAK,IAAI,EAAE;MAC5B,OAAO,EAAE,CAAC,CAAC;IACb;IACA,OAAOG,IAAI,CAACC,KAAK,CAACJ,eAAe,CAAC;EACpC,CAAC,CAAC,OAAOK,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAAC,wCAAwC,EAAEF,GAAG,CAAC;IAC5D,OAAO,EAAE,CAAC,CAAC;EACb;AACF,CAAC;;AAED;AACA,MAAMG,SAAS,GAAIC,KAAK,IAAK;EAC3B,IAAI;IACF,MAAMT,eAAe,GAAGG,IAAI,CAACO,SAAS,CAACD,KAAK,CAAC;IAC7CR,YAAY,CAACU,OAAO,CAAC,OAAO,EAAEX,eAAe,CAAC;EAChD,CAAC,CAAC,OAAOK,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAAC,sCAAsC,EAAEF,GAAG,CAAC;IAC1D;EACF;AACF,CAAC;AAED,MAAMO,YAAY,GAAGb,SAAS,CAAC,CAAC,CAAC,CAAC;;AAElC,OAAO,MAAMc,SAAS,GAAGf,WAAW,CAAC;EACnCgB,IAAI,EAAE,OAAO;EACbF,YAAY;EACZG,QAAQ,EAAE;IACR;IACAC,OAAO,EAAEA,CAACP,KAAK,EAAEQ,MAAM,KAAK;MAC1B,MAAMC,OAAO,GAAG;QACdC,EAAE,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;QAAE;QAChBC,IAAI,EAAEL,MAAM,CAACM,OAAO;QAAE;QACtBC,SAAS,EAAE,KAAK,CAAE;MACpB,CAAC;MACDf,KAAK,CAACgB,IAAI,CAACP,OAAO,CAAC,CAAC,CAAC;MACrBV,SAAS,CAACC,KAAK,CAAC,CAAC,CAAC;IACpB,CAAC;IACD;IACAiB,UAAU,EAAEA,CAACjB,KAAK,EAAEQ,MAAM,KAAK;MAC7B,MAAMU,QAAQ,GAAGlB,KAAK,CAACmB,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACV,EAAE,KAAKF,MAAM,CAACM,OAAO,CAAC,CAAC,CAAC;MACnEf,SAAS,CAACmB,QAAQ,CAAC,CAAC,CAAC;MACrB,OAAOA,QAAQ,CAAC,CAAC;IACnB,CAAC;IACD;IACAG,UAAU,EAAEA,CAACrB,KAAK,EAAEQ,MAAM,KAAK;MAC5B,MAAMY,IAAI,GAAGpB,KAAK,CAACsB,IAAI,CAACF,IAAI,IAAIA,IAAI,CAACV,EAAE,KAAKF,MAAM,CAACM,OAAO,CAAC;MAC3D,IAAIM,IAAI,EAAE;QACRA,IAAI,CAACL,SAAS,GAAG,CAACK,IAAI,CAACL,SAAS;MAClC;MACAhB,SAAS,CAACC,KAAK,CAAC,CAAC,CAAC;IACrB;EACF;AACF,CAAC,CAAC;;AAEF;AACA,OAAO,MAAM;EAAEO,OAAO;EAAEU,UAAU;EAAEI;AAAW,CAAC,GAAGjB,SAAS,CAACmB,OAAO;;AAEpE;AACA,eAAenB,SAAS,CAACoB,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}